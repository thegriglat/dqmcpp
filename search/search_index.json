{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DQMCpp DQMCpp is a C++ library for operating and analysing CMS DQM data. Source code is available on github.com . How to start with DQMCpp: Installation and configuration Documentation List of examples Contacts: Grigory Latyshev Dmitri Konstantinov How to contribute : push pull requests and/or open issues on github.com .","title":"Home"},{"location":"#welcome-to-dqmcpp","text":"DQMCpp is a C++ library for operating and analysing CMS DQM data. Source code is available on github.com . How to start with DQMCpp: Installation and configuration Documentation List of examples Contacts: Grigory Latyshev Dmitri Konstantinov How to contribute : push pull requests and/or open issues on github.com .","title":"Welcome to DQMCpp"},{"location":"examples/","text":"List of examples To compile and run examples follow installation instruction. To compile: cd DQMCpp mkdir build cd build cmake -DPLUGINDIR=../examples ../src make -j nproc To run: touch dummy ## as dqm utility requires file with runs # examples itself doesn't require any runs (if not specially mentioned) ./dqm dummy <example plugin name> # for example ./dqm dummy hello_world Comments and explanations to code are inlined (mostly in plugin.cc files). List of examples: Hello world Simple \"Hello world\" plugin which does nothing. Just to see how to use namespaces, plugin registration and write mandatory C++ code. Making HTTP requests Plugin to learn how to get content by URL in different ways. Channel database Plugin to learn how to operate with ECAL channel database. Parallel processing Plugin to learn how to easily run your functions in parallel. To be added ... Of course the best examples are real PFG plugins","title":"Examples"},{"location":"examples/#list-of-examples","text":"To compile and run examples follow installation instruction. To compile: cd DQMCpp mkdir build cd build cmake -DPLUGINDIR=../examples ../src make -j nproc To run: touch dummy ## as dqm utility requires file with runs # examples itself doesn't require any runs (if not specially mentioned) ./dqm dummy <example plugin name> # for example ./dqm dummy hello_world Comments and explanations to code are inlined (mostly in plugin.cc files). List of examples: Hello world Simple \"Hello world\" plugin which does nothing. Just to see how to use namespaces, plugin registration and write mandatory C++ code. Making HTTP requests Plugin to learn how to get content by URL in different ways. Channel database Plugin to learn how to operate with ECAL channel database. Parallel processing Plugin to learn how to easily run your functions in parallel. To be added ... Of course the best examples are real PFG plugins","title":"List of examples"},{"location":"installation/","text":"Installation Required packages To compile and use DQMCpp you need: C++ compiler with at least C++11 support (GCC and Clang usually) CMake cURL library and headers installed make utility Doxygen to generate documentation Debian-like systems (Debian, Ubuntu) sudo apt-get install make g++ cmake libcurl4 libcurl4-openssl-dev Centos-like systems sudo yum install make g++ cmake libcurl4 libcurl4-openssl-devel Build from source At the moment we don't provide pre-built packages, so you have to build DQMCpp from source. Here a copy-paste snippet to clone and build default DQMCpp libraries (with ECAL PFG plugins). git clone https://github.com/thegriglat/dqmcpp.git cd DQMCpp mkdir build cd build cmake ../src make # or make -j $(nproc) To specify your own plugin diretory use cmake -DPLUGINDIR option. Build documentation cd DQMCpp make docs Documentation will be written in doxygen directory. Configuration Prepare certificate and decrypted key files Obtain GRID certificate if you don't have one. Then you need to save your GRID certificate in p12 format. It is the same format as used by voms-proxy-init . Please follow instructions provided by CERN for IE , Firefox or Mac . Extract certificate part by executing openssl pkcs12 -in myCert.p12 -clcerts -nokeys -out usercert.pem (you will be asked for the password used when saving the certificate) Extract private key by executing openssl pkcs12 -in myCert.p12 -nocerts -out userkey_encrypted.pem (you will be asked for the password used when saving the certificate, and then for a password to encrypt the key with). Decrypt private key: openssl rsa -in userkey_encrypted.pem -out userkey.pem (you will be asked for the password from Step 3). You can now remove userkey_encrypted.pem Change permissions for the decrypted key: chmod go-rw userkey.pem After these steps copy userkey.pem and usercert.pem to ~/.globus directory (default for CERN lxplus) Configuration done!","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#required-packages","text":"To compile and use DQMCpp you need: C++ compiler with at least C++11 support (GCC and Clang usually) CMake cURL library and headers installed make utility Doxygen to generate documentation","title":"Required packages"},{"location":"installation/#debian-like-systems-debian-ubuntu","text":"sudo apt-get install make g++ cmake libcurl4 libcurl4-openssl-dev","title":"Debian-like systems (Debian, Ubuntu)"},{"location":"installation/#centos-like-systems","text":"sudo yum install make g++ cmake libcurl4 libcurl4-openssl-devel","title":"Centos-like systems"},{"location":"installation/#build-from-source","text":"At the moment we don't provide pre-built packages, so you have to build DQMCpp from source. Here a copy-paste snippet to clone and build default DQMCpp libraries (with ECAL PFG plugins). git clone https://github.com/thegriglat/dqmcpp.git cd DQMCpp mkdir build cd build cmake ../src make # or make -j $(nproc) To specify your own plugin diretory use cmake -DPLUGINDIR option.","title":"Build from source"},{"location":"installation/#build-documentation","text":"cd DQMCpp make docs Documentation will be written in doxygen directory.","title":"Build documentation"},{"location":"installation/#configuration","text":"Prepare certificate and decrypted key files Obtain GRID certificate if you don't have one. Then you need to save your GRID certificate in p12 format. It is the same format as used by voms-proxy-init . Please follow instructions provided by CERN for IE , Firefox or Mac . Extract certificate part by executing openssl pkcs12 -in myCert.p12 -clcerts -nokeys -out usercert.pem (you will be asked for the password used when saving the certificate) Extract private key by executing openssl pkcs12 -in myCert.p12 -nocerts -out userkey_encrypted.pem (you will be asked for the password used when saving the certificate, and then for a password to encrypt the key with). Decrypt private key: openssl rsa -in userkey_encrypted.pem -out userkey.pem (you will be asked for the password from Step 3). You can now remove userkey_encrypted.pem Change permissions for the decrypted key: chmod go-rw userkey.pem After these steps copy userkey.pem and usercert.pem to ~/.globus directory (default for CERN lxplus) Configuration done!","title":"Configuration"},{"location":"structure/","text":"Project structure in progress ...","title":"Project structure"},{"location":"structure/#project-structure","text":"in progress ...","title":"Project structure"},{"location":"documentation/","text":"Documentation Common overview DQMCpp is written to respect modularity. Each plugin is simular to standalone program, the only difference is Process(void) function which is called instead of main(int, char**) . To read list of runs a plugin has access to runListReader private pointer: runListReader->runs() # will return std::vector<dqmcpp::ECAL::Run> Reading, parsing and analysing data has to be done by plugin itself. There are no restrictions for that. Doxygen documentation Prepare doxygen docs vith cd DQMCpp make docs # see 'doxygen' directory First plugin Copy hello_world example to a new directory, run cmake -DPLUGINDIR=<your example dir> and build project. Also check examples page. You will be able to see your plugin in dqm help output dqm # or dqm -h # or dqm --help # then run dqm runfile <plugin name> !!! All plugins must be in dqmcpp::plugins namespace !!! Getting data from CMS DQM See here Data structures By default DQMCpp provides a few data structures for analysis. All of them can be found in src/ECAL.hh They are: Point1D for one-dimenstional histograms Point2D for two-dimensional histograms Channel for ECAL channels TT (trigger tower) for ECAL TTs CCU for ECAL CCUs TTCCU to handle TT and CCU both in STL containers Run to keep runnumber and dataset in one struct Templated types: Data<T> (templated key and double value) RunData<T> (Run with templated Data) Here a list of some predefined types: template <typename T> struct Data { T base; double value; }; template <typename T> struct RunData { Run run; T data; }; using ChannelData = Data<Channel>; using TTData = Data<TT>; using CCUData = Data<CCU>; using TTCCUData = Data<TTCCU>; using Data1D = Data<Point1D>; using Data2D = Data<Point2D>; using RunTTData = RunData<std::vector<TTData>>; using RunCCUData = RunData<std::vector<CCUData>>; using RunTTCCUData = RunData<std::vector<TTCCUData>>; using RunChannelData = RunData<std::vector<ChannelData>>; using RunData2D = RunData<std::vector<Data2D>>; using RunData1D = RunData<std::vector<Data1D>>;","title":"Documentation"},{"location":"documentation/#documentation","text":"","title":"Documentation"},{"location":"documentation/#common-overview","text":"DQMCpp is written to respect modularity. Each plugin is simular to standalone program, the only difference is Process(void) function which is called instead of main(int, char**) . To read list of runs a plugin has access to runListReader private pointer: runListReader->runs() # will return std::vector<dqmcpp::ECAL::Run> Reading, parsing and analysing data has to be done by plugin itself. There are no restrictions for that.","title":"Common overview"},{"location":"documentation/#doxygen-documentation","text":"Prepare doxygen docs vith cd DQMCpp make docs # see 'doxygen' directory","title":"Doxygen documentation"},{"location":"documentation/#first-plugin","text":"Copy hello_world example to a new directory, run cmake -DPLUGINDIR=<your example dir> and build project. Also check examples page. You will be able to see your plugin in dqm help output dqm # or dqm -h # or dqm --help # then run dqm runfile <plugin name> !!! All plugins must be in dqmcpp::plugins namespace !!!","title":"First plugin"},{"location":"documentation/#getting-data-from-cms-dqm","text":"See here","title":"Getting data from CMS DQM"},{"location":"documentation/#data-structures","text":"By default DQMCpp provides a few data structures for analysis. All of them can be found in src/ECAL.hh They are: Point1D for one-dimenstional histograms Point2D for two-dimensional histograms Channel for ECAL channels TT (trigger tower) for ECAL TTs CCU for ECAL CCUs TTCCU to handle TT and CCU both in STL containers Run to keep runnumber and dataset in one struct Templated types: Data<T> (templated key and double value) RunData<T> (Run with templated Data) Here a list of some predefined types: template <typename T> struct Data { T base; double value; }; template <typename T> struct RunData { Run run; T data; }; using ChannelData = Data<Channel>; using TTData = Data<TT>; using CCUData = Data<CCU>; using TTCCUData = Data<TTCCU>; using Data1D = Data<Point1D>; using Data2D = Data<Point2D>; using RunTTData = RunData<std::vector<TTData>>; using RunCCUData = RunData<std::vector<CCUData>>; using RunTTCCUData = RunData<std::vector<TTCCUData>>; using RunChannelData = RunData<std::vector<ChannelData>>; using RunData2D = RunData<std::vector<Data2D>>; using RunData1D = RunData<std::vector<Data1D>>;","title":"Data structures"},{"location":"documentation/dqm/","text":"Working with CMS DQM DQMCpp uses cURL library to request JSON (really JSON-like) data from CMS DQM. Also to avoid DDoS of DQM we populate own cache with DQM data (by default in $TMP directory). The cache directory can be overridden by CACHEDIR environment variable. By default all HTTP requests are cached and called sync. Non-caching request are also possible. We provide relative low level functions to make request as well as high level parsers for DQM JSON for ECAL channels , trigger towers , CCU and custom 1/2-D histograms. For parsing JSON nlohmann json library is used. DQM URL Usually url is obtained from CMS DQM online or offline web pages by hand. Url consists of from runnumber , dataset and plot-specific path. To construct url with given EB/EE number use dqmcpp::common::string_format() (it's like printf on steroids): std::string formatted_url = dqmcpp::common::string_format( \"EcalEndcap/EEPedestalOnlineTask/Gain12/EEPOT pedestal EE%+03d G12\", +5); where +5 is SM (super module) number. Then pass this formatted_url to dqmcpp::net::DQMURL::dqmurl() to get DQM url for given runnumber and dataset : std::string dqm_url = dqmcpp::net::DQMURL::dqmurl(runnumber, dataset, formatted_url) Also using dqmcpp::ECAL::Run object is possible auto run = dqmcpp::ECAL::Run(123456, \"online\"); std::string dqm_url = dqmcpp::net::DQMURL::dqmurl(run, dqmcpp::common::string_format( \"EcalEndcap/EEPedestalOnlineTask/Gain12/EEPOT pedestal EE%+03d G12\", +5);) HTTP requests ALL REQUESTS ARE SYNCHRONOUS cURL library is used to process requests. Non-cached requests To process request you have to use URLHandler object #include <string> #include \"URLHandler.hh\" dqmcpp::net::URLHandler urlhdlr; // will be automatically and properly closed and deleted after quitting scope std::string url = \"http://foo.bar\"; std::string content = urlhdlr.get(url); // make synchronous request Cached requests To process cached request you have to use URLCache object #include <string> #include \"net/URLCache.hh\" std::string url = \"http://foo.bar\"; std::string content = dqmcpp::net::URLCache::get(url); It is possible to request multiple data at one call #include <vector> #include <string> #include \"net/URLCache.hh\" std::vector<std::string> urls = {\"http://foo.bar\", \"http://my.super.site\"}; std::vector<std::string> contents = dqmcpp::net::URLCache::get(urls); Parsing JSON data to be continued ....","title":"Working with CMS DQM"},{"location":"documentation/dqm/#working-with-cms-dqm","text":"DQMCpp uses cURL library to request JSON (really JSON-like) data from CMS DQM. Also to avoid DDoS of DQM we populate own cache with DQM data (by default in $TMP directory). The cache directory can be overridden by CACHEDIR environment variable. By default all HTTP requests are cached and called sync. Non-caching request are also possible. We provide relative low level functions to make request as well as high level parsers for DQM JSON for ECAL channels , trigger towers , CCU and custom 1/2-D histograms. For parsing JSON nlohmann json library is used.","title":"Working with CMS DQM"},{"location":"documentation/dqm/#dqm-url","text":"Usually url is obtained from CMS DQM online or offline web pages by hand. Url consists of from runnumber , dataset and plot-specific path. To construct url with given EB/EE number use dqmcpp::common::string_format() (it's like printf on steroids): std::string formatted_url = dqmcpp::common::string_format( \"EcalEndcap/EEPedestalOnlineTask/Gain12/EEPOT pedestal EE%+03d G12\", +5); where +5 is SM (super module) number. Then pass this formatted_url to dqmcpp::net::DQMURL::dqmurl() to get DQM url for given runnumber and dataset : std::string dqm_url = dqmcpp::net::DQMURL::dqmurl(runnumber, dataset, formatted_url) Also using dqmcpp::ECAL::Run object is possible auto run = dqmcpp::ECAL::Run(123456, \"online\"); std::string dqm_url = dqmcpp::net::DQMURL::dqmurl(run, dqmcpp::common::string_format( \"EcalEndcap/EEPedestalOnlineTask/Gain12/EEPOT pedestal EE%+03d G12\", +5);)","title":"DQM URL"},{"location":"documentation/dqm/#http-requests","text":"ALL REQUESTS ARE SYNCHRONOUS cURL library is used to process requests.","title":"HTTP requests"},{"location":"documentation/dqm/#non-cached-requests","text":"To process request you have to use URLHandler object #include <string> #include \"URLHandler.hh\" dqmcpp::net::URLHandler urlhdlr; // will be automatically and properly closed and deleted after quitting scope std::string url = \"http://foo.bar\"; std::string content = urlhdlr.get(url); // make synchronous request","title":"Non-cached requests"},{"location":"documentation/dqm/#cached-requests","text":"To process cached request you have to use URLCache object #include <string> #include \"net/URLCache.hh\" std::string url = \"http://foo.bar\"; std::string content = dqmcpp::net::URLCache::get(url); It is possible to request multiple data at one call #include <vector> #include <string> #include \"net/URLCache.hh\" std::vector<std::string> urls = {\"http://foo.bar\", \"http://my.super.site\"}; std::vector<std::string> contents = dqmcpp::net::URLCache::get(urls);","title":"Cached requests"},{"location":"documentation/dqm/#parsing-json-data","text":"to be continued ....","title":"Parsing JSON data"}]}