{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to DQMCpp DQMCpp is a C++ library for operating and analysing CMS DQM data. Source code is available on CERN gitlab . To learn how to start with DQMCpp read: Installation and configuration DQMCpp structure Working with CMS DQM Writing own analysis List of examples Contacts: Grigory Latyshev Dmitri Konstantinov","title":"Home"},{"location":"#welcome-to-dqmcpp","text":"DQMCpp is a C++ library for operating and analysing CMS DQM data. Source code is available on CERN gitlab . To learn how to start with DQMCpp read: Installation and configuration DQMCpp structure Working with CMS DQM Writing own analysis List of examples Contacts: Grigory Latyshev Dmitri Konstantinov","title":"Welcome to DQMCpp"},{"location":"dqm/","text":"Working with CMS DQM DQMCpp uses cURL library to request JSON (really JSON-like) data from CMS DQM. Also to avoid DDoS of DQM we populate own cache with DQM data (by default in $TMP directory). The cache directory can be overridden by CACHEDIR environment variable. By default all HTTP requests are cached. Non-caching request are also possible. We provide relative low level functions to make request as well as high level parsers for DQM JSON for ECAL channels , trigger towers , CCU . For parsing JSON nlohmann json library is used. HTTP requests ALL REQUESTS ARE SYNCHRONOUS Non-cached low-level requests To process low-level request you have to use URLHandler object #include <string> #include \"URLHandler.hh\" dqmcpp::net::URLHandler urlhdlr; // will be automatically and properly closed and deleted after quitting scope std::string url = \"http://foo.bar\"; std::string content = urlhdlr.get(url); // make synchronous request Cached low-level requests To process low-level request you have to use URLCache object #include <string> #include \"net/URLCache.hh\" std::string url = \"http://foo.bar\"; std::string content = dqmcpp::net::URLCache::get(url); It is possible to request multiple data at one call #include <vector> #include <string> #include \"net/URLCache.hh\" std::vector<std::string> urls = {\"http://foo.bar\", \"http://my.super.site\"}; std::vector<std::string> contents = dqmcpp::net::URLCache::get(urls); Parsing JSON data to be continued ....","title":"Working with CMS DQM"},{"location":"dqm/#working-with-cms-dqm","text":"DQMCpp uses cURL library to request JSON (really JSON-like) data from CMS DQM. Also to avoid DDoS of DQM we populate own cache with DQM data (by default in $TMP directory). The cache directory can be overridden by CACHEDIR environment variable. By default all HTTP requests are cached. Non-caching request are also possible. We provide relative low level functions to make request as well as high level parsers for DQM JSON for ECAL channels , trigger towers , CCU . For parsing JSON nlohmann json library is used.","title":"Working with CMS DQM"},{"location":"dqm/#http-requests","text":"ALL REQUESTS ARE SYNCHRONOUS","title":"HTTP requests"},{"location":"dqm/#non-cached-low-level-requests","text":"To process low-level request you have to use URLHandler object #include <string> #include \"URLHandler.hh\" dqmcpp::net::URLHandler urlhdlr; // will be automatically and properly closed and deleted after quitting scope std::string url = \"http://foo.bar\"; std::string content = urlhdlr.get(url); // make synchronous request","title":"Non-cached low-level requests"},{"location":"dqm/#cached-low-level-requests","text":"To process low-level request you have to use URLCache object #include <string> #include \"net/URLCache.hh\" std::string url = \"http://foo.bar\"; std::string content = dqmcpp::net::URLCache::get(url); It is possible to request multiple data at one call #include <vector> #include <string> #include \"net/URLCache.hh\" std::vector<std::string> urls = {\"http://foo.bar\", \"http://my.super.site\"}; std::vector<std::string> contents = dqmcpp::net::URLCache::get(urls);","title":"Cached low-level requests"},{"location":"dqm/#parsing-json-data","text":"to be continued ....","title":"Parsing JSON data"},{"location":"examples/","text":"List of examples To compile and run examples follow installation instruction. To compile: cd DQMCpp mkdir build cd build cmake -DPLUGINDIR=../examples ../src make -j nproc To run: touch dummy ## as dqm utility requires file with runs # examples itself doesn't require any runs (if not specially mentioned) ./dqm dummy <example plugin name> # for example ./dqm dummy hello_world Comments and explanations to code are inlined (mostly in plugin.cc files). Please see file contents. List of examples: Hello world Simple \"Hello world\" plugin which does nothing. Just to see how to use namespaces, plugin registration and write mandatory C++ code. Making HTTP requests Plugin to learn how to get content by URL in different ways. Channel database Plugin to learn how to operate with ECAL channel database. Parallel processing Plugin to learn how to easily run your functions in parallel. To be added ... Of course the best examples are real plugins","title":"Examples"},{"location":"examples/#list-of-examples","text":"To compile and run examples follow installation instruction. To compile: cd DQMCpp mkdir build cd build cmake -DPLUGINDIR=../examples ../src make -j nproc To run: touch dummy ## as dqm utility requires file with runs # examples itself doesn't require any runs (if not specially mentioned) ./dqm dummy <example plugin name> # for example ./dqm dummy hello_world Comments and explanations to code are inlined (mostly in plugin.cc files). Please see file contents. List of examples: Hello world Simple \"Hello world\" plugin which does nothing. Just to see how to use namespaces, plugin registration and write mandatory C++ code. Making HTTP requests Plugin to learn how to get content by URL in different ways. Channel database Plugin to learn how to operate with ECAL channel database. Parallel processing Plugin to learn how to easily run your functions in parallel. To be added ... Of course the best examples are real plugins","title":"List of examples"},{"location":"howto/","text":"Writing your own plugin in progress ...","title":"Writing your own plugin"},{"location":"howto/#writing-your-own-plugin","text":"in progress ...","title":"Writing your own plugin"},{"location":"installation/","text":"Installation Required packages DQMCpp is C++ library, you need: C++ compiler with at least C++11 support (GCC and Clang usually) CMake cURL library and headers installed make utility Doxygen to generate documentation Debian-like systems (Debian, Ubuntu) sudo apt-get install make g++ cmake libcurl4 libcurl4-openssl-dev Centos-like systems sudo yum install make g++ cmake libcurl4 libcurl4-openssl-devel Build from source At the moment we don't provide built packages, so you have to build DQMCpp from source. Here a copy-paste snippet to clone and build default DQMCpp libraries (with ECAL PFG plugins). git clone https://gitlab.cern.ch/ECALPFG/DQMCpp.git cd DQMCpp mkdir build cd build cmake ../src make # or make -j $(nproc) To specify your own plugin diretory use cmake -DPLUGINDIR option. Build documentation cd DQMCpp make docs Documentation will be written in doxygen directory. Configuration Prepare certificate and decrypted key files Obtain GRID certificate if you don't have one. Then you need to save your GRID certificate in p12 format. It is the same format as used by voms-proxy-init . Please follow instructions provided by CERN for IE , Firefox or Mac . Extract certificate part by executing openssl pkcs12 -in myCert.p12 -clcerts -nokeys -out usercert.pem (you will be asked for the password used when saving the certificate) Extract private key by executing openssl pkcs12 -in myCert.p12 -nocerts -out userkey_encrypted.pem (you will be asked for the password used when saving the certificate, and then for a password to encrypt the key with). Decrypt private key: openssl rsa -in userkey_encrypted.pem -out userkey.pem (you will be asked for the password from Step 3). You can now remove userkey_encrypted.pem Change permissions for the decrypted key: chmod go-rw userkey.pem After these steps copy userkey.pem and usercert.pem to ~/.globus directory (default for CERN lxplus) Configuration done!","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#required-packages","text":"DQMCpp is C++ library, you need: C++ compiler with at least C++11 support (GCC and Clang usually) CMake cURL library and headers installed make utility Doxygen to generate documentation","title":"Required packages"},{"location":"installation/#debian-like-systems-debian-ubuntu","text":"sudo apt-get install make g++ cmake libcurl4 libcurl4-openssl-dev","title":"Debian-like systems (Debian, Ubuntu)"},{"location":"installation/#centos-like-systems","text":"sudo yum install make g++ cmake libcurl4 libcurl4-openssl-devel","title":"Centos-like systems"},{"location":"installation/#build-from-source","text":"At the moment we don't provide built packages, so you have to build DQMCpp from source. Here a copy-paste snippet to clone and build default DQMCpp libraries (with ECAL PFG plugins). git clone https://gitlab.cern.ch/ECALPFG/DQMCpp.git cd DQMCpp mkdir build cd build cmake ../src make # or make -j $(nproc) To specify your own plugin diretory use cmake -DPLUGINDIR option.","title":"Build from source"},{"location":"installation/#build-documentation","text":"cd DQMCpp make docs Documentation will be written in doxygen directory.","title":"Build documentation"},{"location":"installation/#configuration","text":"Prepare certificate and decrypted key files Obtain GRID certificate if you don't have one. Then you need to save your GRID certificate in p12 format. It is the same format as used by voms-proxy-init . Please follow instructions provided by CERN for IE , Firefox or Mac . Extract certificate part by executing openssl pkcs12 -in myCert.p12 -clcerts -nokeys -out usercert.pem (you will be asked for the password used when saving the certificate) Extract private key by executing openssl pkcs12 -in myCert.p12 -nocerts -out userkey_encrypted.pem (you will be asked for the password used when saving the certificate, and then for a password to encrypt the key with). Decrypt private key: openssl rsa -in userkey_encrypted.pem -out userkey.pem (you will be asked for the password from Step 3). You can now remove userkey_encrypted.pem Change permissions for the decrypted key: chmod go-rw userkey.pem After these steps copy userkey.pem and usercert.pem to ~/.globus directory (default for CERN lxplus) Configuration done!","title":"Configuration"},{"location":"structure/","text":"Project structure in progress ...","title":"Project structure"},{"location":"structure/#project-structure","text":"in progress ...","title":"Project structure"}]}